#include <stdio.h>
#include <stdlib.h>
#define SIZE 4
#define HALF 2

int cod;

typedef struct{
    int id;
}D;

typedef struct{
    int id;                 //id do nodo
    D info[SIZE];           //informações do nodo
    struct N *c[SIZE + 1];  //ponteiro pros filhos
    struct N *r;            //nodo da direita
    short s;                //numero de itens no nodo
}N;

typedef struct{
    N *root;
    int size;
}BPT;

BPT * initBPT(){
    BPT *bpt = (BPT*)malloc(sizeof(BPT));
  /*  int i;
    for(i=0;i<SIZE;i++){
        bpt->root->info[i].id=-1;
        bpt->root->c[i]=NULL;

    }

    bpt->root->c[i]=NULL;
    */
    bpt->root=NULL;
    //bpt->root->id=0;
    bpt->size=0;
    //bpt->root->s=0;
    return bpt;
}
N * initN(){
    N *n = (N*)malloc(sizeof(N));
    int i;
    for(i=0;i<SIZE;i++){
        n->info[i].id=-1;
        n->c[i]=NULL;

    }
    n->r=NULL;
    n->s=0;
    n->id=cod;
    cod++;
    n->c[i]=NULL;
    return n;
}

N * add(N *n, D d,N *nc){
    int i, added = 0;
    for(i = 0;i < SIZE;i++){
        if(n->info[i].id == -1){
            n->info[i] = d;
            n->s++;
            added = 1;
            return NULL;
        }
        if(n->s<4){

            if(d.id < n->info[i].id){

                int j;
                D aux = n->info[i];
                D aux2 = n->info[i + 1];
                n->info[i] = d;
                for(j = i + 1; j < SIZE; j++){
                    aux2 = n->info[j];
                    n->info[j] = aux;
                    aux = aux2;
                }
                n->s++;
                return NULL;
            }
        }
        if(n->s==4){
            int posNew;
            D auxD[SIZE + 1];
            int j,setted=0;
            for(j=0;j<SIZE + 1; j++) auxD[j].id=-1;
            for(j=0;j<SIZE + 1; j++){
                if(!setted){
                    if(d.id >= n->info[j].id){
                    auxD[j]=n->info[j];
                    }else{
                        auxD[j]=d;
                        setted=1;
                        posNew=j;
                    }
                }else
                    auxD[j]=n->info[j - 1];
                }
         //   }
            N *newNode=initN();
            for(i=HALF,j=0;i<SIZE;j++,i++){
                newNode->info[j] = auxD[i];
                n->info[i].id=-1;
                n->c[i]=NULL;
                newNode->c[j] = n->c[i];
            }
            if(posNew>=HALF){
                for(i=SIZE-1;i>0;i--){
                    newNode->c[i]=newNode->c[i-1];

                }
            }
            newNode->info[j] = auxD[i];
            n->c[i]=NULL;
            n->s=HALF;
            newNode->s=HALF+1;
            return newNode;
            // printf("\n %d %d %d %d %d",auxD[0].id,auxD[1].id,auxD[2].id,auxD[3].id,auxD[4].id);
            break;
        }
    }
}

N * insert(BPT *root, N *nod, D info){
    int i;

    if(root->root == NULL){
        N *newNode = initN();
        add(newNode,info);
        root->root=newNode;
    }else{
        int allNull=1;
        for(i=0;i<SIZE;i++)
            if(nod->c[i]!=NULL)
                allNull=0;
        if(allNull){
            if(nod->id==root->root->id){
                N* auxNode = add(nod,info,NULL);
                if(auxNode){
                    N* newRoot = initN();
                    newRoot->c[1]=auxNode;
                    newRoot->info[0]=auxNode->info[0];
                    newRoot->c[0]=root->root;
                    root->root=newRoot;
                    nod->r=auxNode;
                    return NULL;
                }
            }else{
                return add(nod,info,NULL);
            }
        }else{
            for(i=0;i<SIZE;i++){
                if(info.id<nod->info[i].id){
                    N* auxNode = insert(root,nod->c[i],info);
                    if(auxNode){
                        return add(nod,auxNode->info[0],auxNode);
                    }
                    break;
                }
                if(info.id > nod->info[SIZE-1].id){
                    N* auxNode = insert(root,nod->c[SIZE],info);
                    break;
                }
            }
        }
    }
   /* for(i=0;i<SIZE;i++){
        if(root->root->info[i].id == -1){
            root->root->info[i] = info;
            root->root->s++;
            return root;
        }
        if(root->root->info[i].id > info.id){
            root->root->c[i] = insert(root,nod->c[i], info);
        }
    }*/
}

void printTree(N *root){
    int i,allNull=1;
    for(i=0;i<SIZE+1;i++)
        if(root->c[i]!=NULL) allNull=0;
    if(allNull)
        for(i=0;i<SIZE;i++)
            printf(" %d ",root->info[i]);
    else{
        for(i=0;i<SIZE+1;i++)
            if(root->c[i]!=NULL) printTree(root->c[i]);
    }
}

void printSequenceTree(BPT *bpt){
    int i,allNull=1;
    N *root=bpt->root;
    for(i=0;i<SIZE+1;i++){
        if(root->c[i]!=NULL){
            root=root->c[0];
            i=-1;
        }
    }
    for(i=0;i<SIZE && root!=NULL;i++){
        printf(" %d ",root->info[i]);
        if(i==SIZE-1){ i=-1; root=root->r;}
    }
}

int main()
{
    cod=0;
    BPT *bpt = initBPT();
    D d;
    d.id=20;
    insert(bpt,bpt->root,d);

    d.id=10;
    insert(bpt,bpt->root,d);

     d.id=30;
    insert(bpt,bpt->root,d);

    d.id=40;
    insert(bpt,bpt->root,d);

    d.id=25;
    insert(bpt,bpt->root,d);

    //printTree(bpt->root);
    printSequenceTree(bpt);
    printf("\n\n");

    return 0;
}
